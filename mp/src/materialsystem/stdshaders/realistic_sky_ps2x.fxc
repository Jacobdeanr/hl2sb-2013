// DYNAMIC: "WRITE_DEPTH_TO_DESTALPHA"	"0..1"	[ps20b] [PC]

#include "common_ps_fxc.h"

struct PS_INPUT
{
    float3 viewDir : TEXCOORD0;
};

// Constants
float4 coeffs0 : register(c0);
float4 coeffs1 : register(c1);
float4 coeffs2 : register(c2);
float4 coeffs3 : register(c3);
float4 coeffs4 : register(c4);
float4 coeffs5 : register(c5);
float4 coeffs6 : register(c6);
float3 radiance : register(c7);
float3 sunDir   : register(c8);
//float turbidity : register(c9);
//float albedo    : register(c10);

// Function to compute the sky radiance using the Hosek-Wilkie model
float3 ComputeSkyRadiance(PS_INPUT i)
{
    float theta = acos(i.viewDir.z);              // Zenith angle
    float gamma = acos(dot(i.viewDir, sunDir));   // Angle between view and sun directions

    // Reconstruct the coefficients array
    float coeffs[27];
    coeffs[0] = coeffs0.x;
    coeffs[1] = coeffs0.y;
    coeffs[2] = coeffs0.z;
    coeffs[3] = coeffs0.w;
    coeffs[4] = coeffs1.x;
    coeffs[5] = coeffs1.y;
    coeffs[6] = coeffs1.z;
    coeffs[7] = coeffs1.w;
    coeffs[8] = coeffs2.x;
    coeffs[9] = coeffs2.y;
    coeffs[10] = coeffs2.z;
    coeffs[11] = coeffs2.w;
    coeffs[12] = coeffs3.x;
    coeffs[13] = coeffs3.y;
    coeffs[14] = coeffs3.z;
    coeffs[15] = coeffs3.w;
    coeffs[16] = coeffs4.x;
    coeffs[17] = coeffs4.y;
    coeffs[18] = coeffs4.z;
    coeffs[19] = coeffs4.w;
    coeffs[20] = coeffs5.x;
    coeffs[21] = coeffs5.y;
    coeffs[22] = coeffs5.z;
    coeffs[23] = coeffs5.w;
    coeffs[24] = coeffs6.x;
    coeffs[25] = coeffs6.y;
    coeffs[26] = coeffs6.z; // coeffs6.w is unused

    // Compute sky radiance using the Hosek-Wilkie model
    float3 skyRadiance = float3(0.0, 0.0, 0.0);

    // For each color component (X, Y, Z)
    for (int comp = 0; comp < 3; comp++)
    {
        int offset = comp * 9;

        float A = coeffs[offset + 0];
        float B = coeffs[offset + 1];
        float C = coeffs[offset + 2];
        float D = coeffs[offset + 3];
        float E = coeffs[offset + 4];
        float F = coeffs[offset + 5];
        float G = coeffs[offset + 6];
        float H = coeffs[offset + 7];
        float I = coeffs[offset + 8];

        // Compute the radiance for this component
        float chi = (1.0 + cos(theta * 0.5)) * (1.0 + cos(theta * 0.5));
        float expTerm = exp(B / (cos(theta) + 0.01));
        float rayMieTerm = (1.0 + C * exp(D * gamma)) * (1.0 + E * exp(F * gamma)) + G * (cos(gamma) * cos(gamma)) + H * cos(gamma) + I;

        skyRadiance[comp] = (A + rayMieTerm) * expTerm * radiance[comp] * chi;
    }

    return skyRadiance;
}

// Function to convert XYZ color space to RGB
float3 XYZ_to_RGB(float3 xyz)
{
    // sRGB color space conversion matrix
    float3x3 M = float3x3(
        3.2406, -1.5372, -0.4986,
       -0.9689,  1.8758,  0.0415,
        0.0557, -0.2040,  1.0570
    );

    return mul(M, xyz);
}


float4 main(PS_INPUT i) : COLOR
{
    // Get sky radiance
    float3 skyRadiance = ComputeSkyRadiance(i);

    // Convert from XYZ to RGB
    float3 skyColor = XYZ_to_RGB(skyRadiance);

    float3 skyColor = float3(0.5,0.5,0);
    float4 finalColor = float4(skyColor, 1.0);

    // Return the final color
    return FinalOutput(finalColor, 0, PIXEL_FOG_TYPE_NONE, TONEMAP_SCALE_LINEAR, 0, 1e20);
}